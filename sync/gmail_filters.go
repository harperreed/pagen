// ABOUTME: Gmail filtering logic for high-signal email detection
// ABOUTME: Filters out newsletters, automated emails, and group messages
package sync

import (
	"fmt"
	"strings"
	"time"

	"google.golang.org/api/gmail/v1"
)

// BuildHighSignalQuery builds a Gmail API query for high-signal emails only
func BuildHighSignalQuery(userEmail string, since time.Time) string {
	// Format: YYYY/MM/DD for Gmail query
	afterDate := since.Format("2006/01/02")

	// Query for:
	// 1. Emails from me that got replies (confirmed engagement)
	// 2. Emails to me that I replied to (active conversation)
	// 3. Starred emails (manually marked important)
	// Exclude spam and trash
	query := fmt.Sprintf(
		"(from:me is:replied) OR (to:me is:replied) OR is:starred after:%s -in:spam -in:trash",
		afterDate,
	)

	return query
}

// IsHighSignalEmail checks if an email meets high-signal criteria
func IsHighSignalEmail(message *gmail.Message, userEmail string) (bool, string) {
	if message == nil {
		return false, "nil message"
	}

	// Extract headers
	headers := parseHeaders(message.Payload)

	// Check for automated sender patterns
	fromAddr := headers["From"]
	if isAutomatedSender(fromAddr) {
		return false, "automated sender"
	}

	// Check for group emails (5+ recipients)
	toAddrs := headers["To"]
	ccAddrs := headers["Cc"]
	recipientCount := countRecipients(toAddrs) + countRecipients(ccAddrs)
	if recipientCount >= 5 {
		return false, fmt.Sprintf("group email (%d recipients)", recipientCount)
	}

	// Check for calendar invites (already synced from Calendar)
	subject := headers["Subject"]
	if isCalendarInvite(subject, message) {
		return false, "calendar invite"
	}

	// Check for empty/auto-generated subjects
	if isAutoGeneratedSubject(subject) {
		return false, "auto-generated subject"
	}

	return true, ""
}

// parseHeaders extracts common email headers from message payload
func parseHeaders(payload *gmail.MessagePart) map[string]string {
	headers := make(map[string]string)

	if payload == nil || payload.Headers == nil {
		return headers
	}

	for _, header := range payload.Headers {
		headers[header.Name] = header.Value
	}

	return headers
}

// isAutomatedSender checks if sender looks like an automated system
func isAutomatedSender(from string) bool {
	if from == "" {
		return true
	}

	lower := strings.ToLower(from)

	// Common automated sender patterns
	automatedPatterns := []string{
		"noreply",
		"no-reply",
		"donotreply",
		"do-not-reply",
		"notifications",
		"notify",
		"mailer-daemon",
		"postmaster",
		"bounces",
		"unsubscribe",
		"newsletter",
		"marketing",
	}

	for _, pattern := range automatedPatterns {
		if strings.Contains(lower, pattern) {
			return true
		}
	}

	return false
}

// countRecipients counts email addresses in a header value (comma-separated)
func countRecipients(headerValue string) int {
	if headerValue == "" {
		return 0
	}

	// Split by comma and count non-empty entries
	parts := strings.Split(headerValue, ",")
	count := 0
	for _, part := range parts {
		if strings.TrimSpace(part) != "" {
			count++
		}
	}

	return count
}

// isCalendarInvite checks if this is a calendar invitation
func isCalendarInvite(subject string, message *gmail.Message) bool {
	if message.Payload == nil {
		return false
	}

	// Check for calendar MIME types
	if message.Payload.MimeType == "text/calendar" {
		return true
	}

	// Check for common calendar subject patterns
	lower := strings.ToLower(subject)
	calendarPhrases := []string{
		"invitation:",
		"invite:",
		"calendar:",
		"updated invitation:",
		"canceled event:",
	}

	for _, phrase := range calendarPhrases {
		if strings.HasPrefix(lower, phrase) {
			return true
		}
	}

	return false
}

// isAutoGeneratedSubject checks if subject looks auto-generated
func isAutoGeneratedSubject(subject string) bool {
	if subject == "" {
		return true
	}

	// Very short subjects are often automated
	if len(strings.TrimSpace(subject)) < 3 {
		return true
	}

	lower := strings.ToLower(subject)

	// Common auto-generated patterns
	autoPatterns := []string{
		"automatic reply:",
		"out of office:",
		"delivery status notification",
		"returned mail:",
		"failure notice",
		"undelivered mail",
	}

	for _, pattern := range autoPatterns {
		if strings.HasPrefix(lower, pattern) {
			return true
		}
	}

	return false
}

// ExtractEmailAddress extracts clean email from "Name <email@domain.com>" format
func ExtractEmailAddress(emailField string) (name string, email string, domain string) {
	if emailField == "" {
		return "", "", ""
	}

	// Check for "Name <email>" format
	if strings.Contains(emailField, "<") && strings.Contains(emailField, ">") {
		parts := strings.Split(emailField, "<")
		if len(parts) >= 2 {
			name = strings.TrimSpace(parts[0])
			name = strings.Trim(name, "\"") // Remove quotes if present

			emailPart := strings.Split(parts[1], ">")[0]
			email = strings.TrimSpace(emailPart)
		}
	} else {
		// Just email address
		email = strings.TrimSpace(emailField)
	}

	// Extract domain
	if email != "" && strings.Contains(email, "@") {
		domainParts := strings.Split(email, "@")
		if len(domainParts) == 2 {
			domain = strings.ToLower(domainParts[1])
		}
	}

	return name, email, domain
}
